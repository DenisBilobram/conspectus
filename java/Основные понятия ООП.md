# Основные понятия ООП

---

## Инкапсуляция (скрытая реализация)

_Спецификаторы доступа_ определяют кто имеет право использовать следующие за ними определения.

**public** означает, что определения доступы всем.

**private** означает, что к определениям не может обратиться никто, кроме создателя типа, внутри методов этого типа. Попытка внешнего обращения к private-членам вызывает ошибку компиляции.

**protected** действует схоже с private, за одним исключением - производные классы имеют доступ к protected-членам, но не имеют к private-членам.

Так же есть доступ по умолчанию, тогда определения являются public для классов внутри пакета, и private для классов вне пакета.

## Полиморфизм

Полиморфизм — одна из трех основных парадигм ООП. Если говорить кратко, полиморфизм — это способность обьекта использовать методы производного класса, который не существует на момент создания базового.

## Однокорневая иерархия

В основе всех иерархии типов лежит единый базовый класс Object.

## Время жизни объектов

Динамическое создание объектов в области памяти, называемой кучей (heap). Каждый раз при создании объекта используется ключевое слово new для построения динамического экземпляра. В java существует механизм, называемый _уборкой мусора_, он автоматически определяет когда можно удалить объект.

Ссылки на объект все же хранятся в стеке, а сами объекты в куче

## Обработка исключений

*Исключение* представляет собй объект, генерируемый на месте возникновения ошибки, который затем может быть перехвачен.

## Параллельное выполнение

Раздельно выполняемые части программы называются потоками, а весь принцип получил название *многопоточность* или *параллельное вычисление*.

## Примитивные типы

Создание объекта с помощью new помещает его в кучу, при работе с очень маленькими переменными это не эффективно. Переменная примитивного типы не является ссылкой и хранится на прямую в стеке.

Классы-обертки позволяют создать в кучне не примитивный объект для представления примитивного типа.

```java
char c = 'x';
Character ch = new Character(c); // or
Character ch = new Character('c');
```

Механизм _автоматической упаковки_ Java SE5 автоматически преобразует примитивный объект в объектную обертку и наооборот:

```java
Character ch = 'x';
char c = ch;
```

## Массивы в Java

При объявлении массива объектов создается массив ссылок на объекты, и каждая из них автоматически инициализируется null.

## Class Java

### Значения по умолчанию для полей примитивных типов![](C:\Users\notttk\AppData\Roaming\marktext\images\2022-10-13-21-11-43-image.png)

Значения по умолчанию гарантируются только в том случае, если переменная используется как _член класса_.

Такая гарантия не относится к _локальным переменным_.

```java
int x;
```

Переменной x будет присвоенно случайное значение, она не будет автоматически инициализирована нулем.

Имя метода и список его аргументов называются _сигнатурой_ метода.

Библиотека классов, присоединяемый автоматически к каждому файлу Java:

java.lang

Оператор new возвращает ссылку на созданный объект, но конструктор ничего не возвращает.

При перегрузке конструктора, можно вызывать другой конструктор прямо из кода конструктора, для этого используется this().

Весь код static выполняется один раз, при создании превого объекта класса или при первом обращении к статическим членам этого класса.

## Инициализация массивов

Массивы используются и определяются при помощи _оператора индексирования_ [].

При создании массива в переменной хранится ссылка на сам массив. При создании массива объектов в массиве хранятся ссылки на объекты.

## Перечисления

```java
public enum Spiciness {
    LOW, MEDIUM, HIGHT
}


Spiciness a = Spiciness.LOW;
switch (a) {
    case LOW, MEDIUM:
        System.out.println("Not so hot!");
        break;
    case HIGHT:
        System.out.println("Hot!!");
        break;
}
```

## Ещё немного полиморфизма

_Позднее связывание_ позволяет базовому классу вызывать методы производного класса и следующие конструкции

```java
Shape p = new Circle();
p.drow();
```

Компилятор не знает drow() какого класса нужно вывзвать, базового Shape или производного Circle, однако механизм _позднего связывания_ позволяет использовать метод класса Circle.

При создании объекта вызываются сначала все конструкторы базовых классво, и лишь затем конструктор производного класса, это гарантирует инициализацию всех полей производного класса, даже private-полей.

_Нисходящее преобразование_ позволяет использовать члены производного класса после _восходящего преобразования_, для этого нужно явно в скобках () указать производный класс.

# 
